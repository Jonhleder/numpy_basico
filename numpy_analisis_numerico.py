# -*- coding: utf-8 -*-
"""Numpy_analisis numerico.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oHuocUB_WUSHR31wD2TxU-4zSnnb7zWV

<a href="https://colab.research.google.com/github/ahcamachod/2044-numpy-analisis-numerico-eficiente-con-python/blob/aula-4/Numpy.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# **Numpy: Análisis numérico eficiente con Python**

NumPy es una biblioteca de Python que ofrece diversas herramientas y funcionalidades esenciales para la computación científica, incluyendo objetos de matriz multidimensional conocidos como *arrays*, rutinas para operaciones rápidas en matrizes, además de operaciones matemáticas, manipulación de formas, estadística entre otros. Es ampliamente utilizada en áreas como análisis de datos, procesamiento de señales y aprendizaje de máquina.

Para acceder a la documentación de esta biblioteca, puedes hacer clic en el siguiente enlace: https://numpy.org/devdocs/index.html

## Importando las bibliotecas y conectando con Drive
"""

import numpy as np
from google.colab import drive

drive.mount('/content/drive')

# 12 * 7 + 3 = 87
np.arange(1,88,1)

# np.loadtxt(url,delimiter=',',usecols = np.arange(1,88,1))

####### Método 2 para cargar el dataset directamente desde Google Drive #####

path = '/content/drive/MyDrive/ALURA/ETL/NumPy/manzanas.csv'

datos = np.loadtxt(path,delimiter=',',usecols = np.arange(1,88,1))

"""## Métodos básicos para explorar *Arrays*"""

datos.ndim

datos.shape

datos

datos.T

datos_transpuestos = datos.T

"""## Visualización y Selección"""

fechas = datos_transpuestos[:,0]
fechas

precios = datos_transpuestos[:,1:]
precios

import matplotlib.pyplot as plt

plt.plot(fechas,precios)

plt.plot(fechas,precios[:,0])

fechas = np.arange(1,88,1)

plt.plot(fechas,precios[:,0])

Moscu = precios[:,0]
Kaliningrado = precios[:,1]
Petersburgo = precios[:,2]
Krasnodar = precios[:,3]
Ekaterimburgo = precios[:,4]

plt.plot(fechas,Kaliningrado)

"""## Comparación entre *arrays*"""

Moscu.shape

moscu_1 = Moscu[0:12]
moscu_2 = Moscu[12:24]
moscu_3 = Moscu[24:36]
moscu_4 = Moscu[36:48]

plt.plot(np.arange(1,13,1),moscu_1)
plt.plot(np.arange(1,13,1),moscu_2)
plt.plot(np.arange(1,13,1),moscu_3)
plt.plot(np.arange(1,13,1),moscu_4)
plt.legend(['2013','2014','2015','2016'])

np.array_equal(moscu_1,moscu_2)

np.allclose(moscu_1,moscu_2, 2)

"""## Tratamiento de Nan"""

np.mean(Moscu)

np.mean(Kaliningrado)

plt.plot(fechas, Kaliningrado)

Kaliningrado

np.isnan(Kaliningrado)

np.sum(np.isnan(Kaliningrado))

Kaliningrado[4] = (Kaliningrado[3] + Kaliningrado[5])/2

np.sum(np.isnan(Kaliningrado))

plt.plot(fechas, Kaliningrado)

np.mean(Kaliningrado)

"""## Diferencia entre *arrays*"""

plt.plot(fechas,Moscu)

"""### **y = ax + b**"""

x = fechas
y = 1.5 * x + 78

y

plt.plot(fechas,Moscu)
plt.plot(x,y)

Moscu - y

np.sqrt(np.sum(np.power(Moscu - y,2)))

x = fechas
y = 0.5 * x + 78

plt.plot(fechas,Moscu)
plt.plot(x,y)

Moscu - y

np.sum(np.power(Moscu - y,2))

np.sqrt(np.sum(np.power(Moscu - y,2)))

np.linalg.norm(Moscu - y)

"""## Multiplicación

$$\alpha = pendiente$$
$$\beta = interseccion$$
$$n = observaciones$$
$$y = precio$$
$$x = fecha$$


La solución para la pendiente es:

$$\alpha = \frac{n \sum xy - \sum x \sum y}{n \sum x^2 - (\sum x)^2} $$

Y para la intersección:
 $$\beta = \frac{\sum y - \alpha \sum x}{n} $$

Y obtenemos la ecuación de la recta:

$$y = \alpha x + \beta $$
"""

n = np.size(Moscu)
y = Moscu
x = fechas

"""$$\alpha = \frac{n \sum xy - \sum x \sum y}{n \sum x^2 - (\sum x)^2} $$"""

a = (n*np.sum(x*y)-np.sum(x)*np.sum(y))/(n*np.sum(x**2) - np.sum(x)**2)

""" $$\beta = \frac{\sum y - \alpha \sum x}{n} $$"""

b = np.mean(y)- a*np.mean(x)

print(f'La pendiente es: {a}\nLa intersección es: {b}')

y = a*x + b

y

np.linalg.norm(Moscu - y)

plt.plot(fechas,Moscu)
plt.plot(x,y)
plt.plot(25,a*25+b,'*r')
plt.plot(75,a*75+b,'*r')

a*25+b

a*75+b

"""## Valores Aleatorios"""

#número entero
np.random.randint(40,100,100)

"""**Explicación de los argumentos:**

40: límite inferior (inclusive) de los valores aleatorios.

100: límite superior (exclusivo) de los valores aleatorios.

100: cantidad de números aleatorios que se generarán.
"""

#número decimal
np.random.uniform(0.1,0.9,100)

pendientes= np.random.uniform(0.1,0.9,100)

for i in range(100):
  print(np.linalg.norm(Moscu - (pendientes[i]*fechas + b)))

norma = np.array([])

for i in range(100):
  norma = np.append(norma, np.linalg.norm(Moscu - (pendientes[i]*fechas + b)))

norma

np.random.seed(99)
np.random.uniform(0.1,0.9,5)

np.random.seed(99)

norma = np.array([])

for i in range(100):
  norma = np.append(norma, np.linalg.norm(Moscu - (pendientes[i]*fechas + b)))

norma

"""## **Exportando el archivo generado**"""

pendientes

norma

datos = np.column_stack([norma,pendientes])

datos

datos.shape

np.savetxt('/content/drive/MyDrive/ALURA/ETL/NumPy/norma_y_pendientes.cvs',datos,delimiter=',')

